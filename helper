#!/usr/bin/env python3
from collections import defaultdict
from pprint      import pprint

import pickle, sys, os
from os.path import expanduser

from lib.schedule import get_schedule
from lib.task     import Task

__home__ = expanduser("~")
filename = __home__ + '/.tasks.pkl'


#******************************************************************************
#  Auxillary
#******************************************************************************

def get_tasks(filename):
    try:
        with open(filename, 'rb') as infile:
            tasks = pickle.load(infile)
    except FileNotFoundError as e:
        tasks = defaultdict(list)
    return tasks

def save_tasks(tasks, filename):
    with open(filename, 'wb') as outfile:
        pickle.dump(tasks, outfile)

def get_possible(tasks, duration):
    keys = [key for key in tasks.keys() if key <= duration]
    if len(keys) == 0:
        return []
    return tasks[keys[0]]


 #******************************************************************************
 #  Subcommands
 #******************************************************************************

def add(tasks, schedule, name, duration, precedence=5, finish=None, prereqs=''):
    duration = int(duration)
    tasks[duration].append(Task(name, duration, precedence, finish, prereqs))

def do(tasks, schedule, duration, overwrite=True):
    duration = int(duration)
    possible = tasks[duration]
    if len(possible) == 0:
        print('No available tasks to be done')
    else:
        print('todo task:')
        print(possible[0])
        if overwrite:
            tasks[duration] = possible[1:]

def see(tasks, schedule, duration):
    duration = int(duration)
    print('todo task would be:')
    do(tasks, schedule, duration, overwrite=False)


def todo(tasks, schedule):
    for duration, item in schedule:
        if item == 'gap':
            return get_possible(tasks, duration)
    return None

def view(tasks, schedule):
    pprint(tasks)

def clear(tasks, schedule):
    if input('Are you sure?').lower() in ['y', 'yes']:
        if os.path.exists(filename):
            os.remove(filename)
        print('Tasks cleared')
    else:
        print('Task clear aborted')

def done(tasks, schedule):
    last = todo(tasks, schedule)
    if last is None or len(last) == 0:
        return
    last = last[0]
    print(last)
    for k, v in tasks.items():
        if last in v:
            v.remove(last)
            break

#******************************************************************************
#  Subcommand tree
#******************************************************************************

commands = {
        'done'  : done,
        'todo'  : todo,
        'clear' : clear,
        'view'  : view,
        'add'   : add,
        'see'   : see,
        'do'    : do
        }

def main(args):
    if len(args) == 0:
        print('Please provide arguments to helper script')
        return 0

    tasks = get_tasks(filename)

    schedule = get_schedule()
    reprstr = 'TASK '
    strs = []
    for i in range(2):
        time, name = schedule[i]
        nextTasks = todo(tasks, schedule)
        if name == 'gap':
            if nextTasks is None or len(nextTasks) == 0:
                strs.append('None ({})m'.format(round(time, 2)))
            else:
                task = nextTasks[0]
                strs.append('{} {}m/{}m'.format(task.name, round(task.duration, 2), round(time, 2)))
        else:
            strs.append('{} {}m'.format(name, round(time, 2)))
    reprstr += ', '.join(strs)
    print(reprstr)

    pprint(schedule)

    subCommand, *text = args
    commands[subCommand](tasks, schedule, *text)

    save_tasks(tasks, filename)
    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
